---
title: Explicit Container Syntax
eleventyNavigation:
  key: query-syntax
  title: Explicit Syntax
  parent: container-queries
---

The overall approach documented in my initial
[Proposal & Explainer](../explainer/)
has been approved by the CSSWG --
but there is still some interest
in adding explicit new syntax
for establishing containment,
as well as new container-relative units.

## General terminology

CSS already has many different types of containers,
containment, containing blocks, etc.
That doesn't necessarily mean
we have to avoid the term "container" entirely --
at this point we're leaning into it with `@container` --
but it does mean we need to define terms carefully.

These are a few of the essential parts,
and the names I'm currently using for them:

- **Container Query**:
  Refers to the entire `@container` rule block
- **Query Container**:
  An element with appropriate containment
  (or whatever else is required)
  to be observed by a _container query_.
- **Containment Context**:
  Context generated by the _query container_,
  which applies to all descendants
  until any nested query container
  establishes a new context.
- **Querying Element**:
  Any element targeted by a selector
  inside of a _container query_.
  The element queries the _containment context_
  established by its _nearest ancestor container_.
- **Nearest Ancestor Container**:
  The specific _query container_ that is
  generating the current _containment context_
  for a given _querying element_.

The word "container" is already used
quite often in CSS, but never on its own.
Still, there are potential confusions with the term --
especially if we want a new `container` property
in addition to the existing `contain` property.
So I
[asked twitter](https://twitter.com/TerribleMia/status/1395440175128342528)
to help brainstorm additional terms:

- People often say "element queries"
  but "element" already has a much too generic meaning
- component?
- module?
- context?
- structure?
- viewbox?
- enclosure?
- compartment?
- Parent?

Despite the issues,
I'll continue using `container` for now --
since it's the name
most people have used for this feature
since ~2010. ðŸ˜‚

But `context` stands out to me
as a reasonable alternative.

## Why add new syntax?

See [CSSWG-drafts issue #6174][6174]
for public discussion of this issue.

[6174]: https://github.com/w3c/csswg-drafts/issues/6174

There are several reasons to consider new syntax
for establishing observable containers:

- Dimensional queries will require containment
  of `layout`, `size` (1d or 2d), and `style`
  (but not `paint`).
  Ideally authors won't have to apply each individually.
- Different [query features](https://github.com/w3c/csswg-drafts/issues/5989)
  will require different types of containment
  (or even no containment at all).
- Authors might apply containment for other reasons,
  and not want to trigger a new containment context for queries.

Since the new syntax will need to set containment values,
currently defined by the `contain` property,
we should attempt to build on top of that existing property.

### Extending the `contain` property

If all query features required containment,
we might think of them as shorthand values
added to the the `contain` property.
Much like the `strict` value,
something like `inline-query`
could apply values of `layout`, `inline-size`, and `style`:

```css
main {
  contain: inline-query;
}
```

Another variant of this might involve a function syntax:

```css
main {
  contain: query(inline-size);
}
```

Pros:

- we're not implicitly setting `contain` values
  based on some entirely separate property.

Cons:

- The difference between normal contain values
  (`inline-size`) and their query-alternates (`inline-query`)
  may be confusing in the same property
- If we allow queries that don't require containment values,
  this seems like the wrong place to specify them
- We'd expect the individual values to _add up_
  and have the same impact as the shorthand --
  which breaks our goal of making the behavior explicit.

### Adding a new property

There is already existing precedent
for other properties to "imply" containment.
[Content-visibility][]
doesn't change the computed value of `contain`,
but it does change the used/applied value --
triggering containment behavior.
We also have features like
[block formatting context][bfc]
that are triggered by
any number of different properties & combinations --
while also now having an explicit `display` value.

[Content-visibility]: https://drafts.csswg.org/css-contain-2/#content-visibility
[bfc]: https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context

From that perspective,
we can think of `contain`
as the explicit hook into
containment minutia --
but "containment" itself as a more generic behavior
that can be triggered in various ways.
Then we could add an explicit new property
custom-designed for establishing
query containers:

```css
main {
  container: inline-size;
}
```

Pros:

- We don't need to differentiate between
  nearly-identical values with different behavior
  in the same property.
- We don't have to "desugar" the shorthand value
  into the same behavior as a set of longhand values.
- We're not constrained by the concept of "containment"
  when adding new query features.
- We can teach a single container-query specific syntax,
  and handle containment as an implementation detail.

Cons:

- More properties trigger containment behavior

**At this point,
a new property seems to me
like the best path forward.**

## Proposed syntax for establishing containers

I'm sure we'll bikeshed
some of the details,
but here's an initial attempt,
which is [also posted to the CSSWG issue][syntax-issue].

[syntax-issue]: https://github.com/w3c/csswg-drafts/issues/6174#issuecomment-846313720

I'm proposing a new `container` property:

```css
.selector {
  container: inline-size;
}
```

This property would:
- Explicitly establish the element as a container
- Establish the types of queries allowed on the container
  (e.g. `inline-size`)
- Apply the minimum required containment
  to make those query types possible
  (e.g. `layout`, `inline-size`, and `style`)

Different [container types][ctype]
(dimensions, states, styles)
are explored below.

This also presents an opportunity for adding
[named containers][cname]
using a custom-identifier
(also explored below).

[cname]: https://css.oddbird.net/rwd/query/proposal/#named-containers

If we do support both name & types,
the `container` property would act as a shorthand:

```css
.selector {
  /* container: [<custom-ident>? <types>+] | none; */
  container: my-widget inline-size style;
}

/* @container <container-query-list> { <stylesheet> } */
@container my-widget (inline-size >= 30em) { /* â€¦ */ }
```

If we do have both a "name" and a list of "types",
we would likely also want longhand properties for each.
Those could be called
`container-name` and `container-type`:

```css
.selector {
  /* container-name: <custom-ident> | none; */
  container-name: page;

  /* container-type: <types>+ | none; */
  container-type: inline-size style;
}
```

### Container name

While I suggested [removing selectors][selectors]
from the `@container` syntax,
having multiple container-types
makes it more likely that there will be reasons
to query different containers in each case.

The new syntax here
also opens up the possibility of creating
more flexible & repeatable
_named_ containers --
not limited to selector-matching:

```css
main, section {
  container-type: inline-size;
  cotainer-name: layout;
}

.my-component {
  container-type: style;
  container-name: component;
}

@container layout (inline-size >= 30em ) { /* â€¦ */ }
@container component (font-size >= 2rem) { /* â€¦ */ }

/* name is optional */
@container (inline-size >= 30em ) { /* â€¦ */ }
```

These queries would resolve as follows:

- If no container name is specified,
  the query condition resolves against the _nearest ancestor container_
- Otherwise,
  find the nearest ancestor container _with the specified name_
  - If no ancestor container matches the specified name,
    the query condition is `false`
  - Otherwise, if a container is found with the proper name,
    the query condition is resolved against that element

You could also query the name of the container,
without any qualifiers.
I'm not sure if that would have
any real use-cases:

```css
@container my-component { /* â€¦ */ }
```

Multiple different containers
could share the same identifier --
and descendants would query the nearest ancestor
with that identifier.

[selectors]: https://css.oddbird.net/rwd/query/explainer/#implicit-vs-explicit-containers

### Container types

This proposal identifies
three broad groups of `container-type`
that an author might want to
observe and query...

#### Observable dimensions

In order to query the dimensions of a container,
we would provide at least two values,
and potentially more.
These would all apply
the necessary layout, size, and style containment:

- `size` --
  contains `layout`, `size`, and `style`
- `inline-size` (or simply `inline`?) --
  contains `layout`, `inline-size`, and `style`
- `block-size`? (or simply `block`?) --
  contains `layout`, `block-size`, and `style`
- `width`? --
  contains `layout`, `width`, and `style`
- `height`? --
  contains `layout`, `height`, and `style`

If block-only containment is not possible,
that will also rule out `width`/`height` as values.

```css
main {
  container: size;
}

@container (inline-size >= 30em) { /* â€¦ */ }
@container (min-aspect-ratio: 8/5) { /* â€¦ */ }
```

It would not make much sense
to apply multiple dimension values at once.

#### Observable styles

We may be able to expose/query
the computed values of other properties
(especially custom properties)
on the container.
We likely only need a single value
to expose that sort of query:

```css
main {
  container: style;
}

@container (--colors == dark) { /* â€¦ */ }
@container (font-size >= 2rem) { /* â€¦ */ }
```

It's not clear to me
what containment (if any)
would be required for this to work.

#### Observable state

There has also been discussion
about querying the "state" of the container:

- Is it "stuck" (using position sticky)?
- Is it snapped-into-place (using scroll-snap)?
- Is it currently in the viewport?

If all "state" queries
require similar containment,
we could use a single keyword for these as well:

```css
main {
  container: state;
}
```

But it seems likely that
different states might require
establishing different types of containment --
in which case each state might need
to be listed individually.
This likely needs more exploration.

From the other end,
I expect we might want to designate
state-queries with a functional syntax:

```css
@container state(stuck) { /* â€¦ */ }
```

In which case we could consider
using a similar functional syntax
for exposing individual states:

```css
main {
  container: state(stuck);
}
```

## Container-relative units

==TBD==
