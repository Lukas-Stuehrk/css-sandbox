---
title: Explicit Container Syntax
eleventyNavigation:
  key: query-syntax
  title: Explicit Syntax
  parent: container-queries
---

The overall approach documented in my initial
[Proposal & Explainer](../explainer/)
has been approved by the CSSWG --
but there is still some interest
in adding explicit new syntax
for establishing containment,
as well as new container-relative units.

## General terminology

CSS already has many different types of containers,
containment, containing blocks, etc.
That doesn't necessarily mean
we have to avoid the term "container" entirely --
at this point we're leaning into it with `@container` --
but it does mean we need to define terms carefully.

These are a few of the essential parts,
and the names I'm currently using for them:

- **Container Query**:
  Refers to the entire `@container` rule block
- **Query Container**:
  An element with appropriate containment
  (or whatever else is required)
  to be observed by a _container query_.
- **Containment Context**:
  Context generated by the _query container_,
  which applies to all descendants
  until any nested query container
  establishes a new context.
- **Querying Element**:
  Any element targeted by a selector
  inside of a _container query_.
  The element queries the _containment context_
  established by its _nearest ancestor container_.
- **Nearest Ancestor Container**:
  The specific _query container_ that is
  generating the current _containment context_
  for a given _querying element_.

The word "container" is already used
quite often in CSS, but never on its own.
Still, there are potential confusions with the term --
especially if we want a new `container` property
in addition to the existing `contain` property.
So I
[asked twitter](https://twitter.com/TerribleMia/status/1395440175128342528)
to help brainstorm additional terms:

- People often say "element queries"
  but "element" already has a much too generic meaning
- component?
- module?
- context?
- structure?
- viewbox?
- enclosure?
- compartment?
- Parent?

Despite the issues,
I'll continue using `container` for now --
since it's the name
most people have used for this feature
since ~2010. ðŸ˜‚

But `context` stands out to me
as a reasonable alternative.

## Why add new syntax?

See [CSSWG-drafts issue #6174][6174]
for public discussion of this issue.

[6174]: https://github.com/w3c/csswg-drafts/issues/6174

There are several reasons to consider new syntax
for establishing observable containers:

- Dimensional queries will require containment
  of `layout`, `size` (1d or 2d), and `style`
  (but not `paint`).
  Ideally authors won't have to apply each individually.
- Different [query features](https://github.com/w3c/csswg-drafts/issues/5989)
  will require different types of containment
  (or even no containment at all).
- Authors might apply containment for other reasons,
  and not want to trigger a new containment context for queries.

Since the new syntax will need to set containment values,
currently defined by the `contain` property,
we should attempt to build on top of that existing property.

### Extending the `contain` property

If all query features required containment,
we might think of them as shorthand values
added to the the `contain` property.
Much like the `strict` value,
something like `inline-query`
could apply values of `layout`, `inline-size`, and `style`:

```css
main {
  contain: inline-query;
}
```

Another variant of this might involve a function syntax:

```css
main {
  contain: query(inline-size);
}
```

Pros:

- we're not implicitly setting `contain` values
  based on some entirely separate property.

Cons:

- The difference between normal contain values
  (`inline-size`) and their query-alternates (`inline-query`)
  may be confusing in the same property
- If we allow queries that don't require containment values,
  this seems like the wrong place to specify them
- We'd expect the individual values to _add up_
  and have the same impact as the shorthand --
  which breaks our goal of making the behavior explicit.

### Adding a new property

There is already existing precedent
for other properties to "imply" containment.
[Content-visibility][]
doesn't change the computed value of `contain`,
but it does change the used/applied value --
triggering containment behavior.
We also have features like
[block formatting context][bfc]
that are triggered by
any number of different properties & combinations --
while also now having an explicit `display` value.

[Content-visibility]: https://drafts.csswg.org/css-contain-2/#content-visibility
[bfc]: https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context

From that perspective,
we can think of `contain`
as the explicit hook into
containment minutia --
but "containment" itself as a more generic behavior
that can be triggered in various ways.
Then we could add an explicit new property
custom-designed for establishing
query containers:

```css
main {
  container: inline-size;
}
```

Pros:

- We don't need to differentiate between
  nearly-identical values with different behavior
  in the same property.
- We don't have to "desugar" the shorthand value
  into the same behavior as a set of longhand values.
- We're not constrained by the concept of "containment"
  when adding new query features.
- We can teach a single container-query specific syntax,
  and handle containment as an implementation detail.

Cons:

- Multiple properties that have the same underlying behavior
  could be confusing?

**At this point,
a new property seems to me
like the best path forward.**

## Proposed syntax for establishing containers

We'll probably want to bikeshed some of the details
and specific terms,
but this is an initial attempt.
As a fallback option,
try substituting `context` for `container`
in all these examples.

I'm proposing two longhand properties,
`container-name` and `container-type`:

```css
.selector {
  /* container-name: <ident> | none; */
  container-name: page;

  /* container-type: <types>+ | none; */
  container-type: inline-size style;
}
```

With a `container` shorthand
that accepts an optional name,
and one or more types:

```css
.selector {
  /* container: [<ident>? <types>+] | none; */
  container: widget inline-size style;
}
```

### Observable dimensions

In order to query the dimensions of a container,
we would provide at least two values,
and potentially more.
These would all apply
the necessary layout, size, and style containment:

- `size`
  (contains `layout`, `size`, and `style`)
- `inline-size`
  (contains `layout`, `inline-size`, and `style`)
- `block-size`?
  (contains `layout`, `block-size`, and `style`)
- `width`?
  (contains `layout`, `width`, and `style`)
- `height`?
  (contains `layout`, `height`, and `style`)

If block-only containment is not possible,
that will also rule out `width`/`height` as values.

```css
main {
  container: size;
}

@container (inline-size >= 30em) { /* â€¦ */ }
@container (min-aspect-ratio: 8/5) { /* â€¦ */ }
```

It would not make much sense
to apply multiple dimension values at once.

### Observable styles

We may be able to expose/query
the computed values of other properties
(especially custom properties)
on the container.
We likely only need a single value
to expose that sort of query:

```css
main {
  container: style;
}

@container (--colors == dark) { /* â€¦ */ }
@container (font-size >= 2rem) { /* â€¦ */ }
```

It's not clear to me
what containment (if any)
would be required for this to work.

### Observable state

There has also been discussion
about querying the "state" of the container:

- Is it "stuck" (using position sticky)?
- Is it snapped-into-place (using scroll-snap)?
- Is it currently in the viewport?

Different states might require
establishing different types of containment,
which might mean they need individual keywords
in order to make them observable?
This likely needs to be explored more.

From the other end,
I expect we might want to designate
state-queries with a functional syntax:

```css
@container state(stuck) { /* â€¦ */ }
```

It might also make sense to

### Named containers?

While I suggested [removing selectors][selectors]
from the `@container` syntax,
having multiple container-types
makes it more likely that there will be reasons
to query specific containers.

But a new syntax here
also opens up the possibility of creating
_named_ containers
in a more flexible way:

```css
main, section {
  container-type: inline-size;
  cotainer-name: layout;
}

.my-component {
  container-type: style;
  container-name: component;
}

@container layout and (inline-size >= 30em ) { /* â€¦ */ }
@container component and (font-size >= 2rem) { /* â€¦ */ }
```

You could also query the name of the container,
without any qualifiers.
I'm not sure if that would have
any real use-cases:

```css
@container my-component { /* â€¦ */ }
```

Multiple different containers
could share the same identifier --
and descendants would query the nearest ancestor
with that identifier.

[selectors]: https://css.oddbird.net/rwd/query/explainer/#implicit-vs-explicit-containers

## Container-relative units

==TBD==
